/**
 * Morph V2.1 - Layer Renderer Engine
 * 
 * Recursively renders the component tree generated by the AI.
 * Maps component names to actual React components.
 * Supports advanced Visual Physics components.
 */

"use client";

import React from "react";
import type { Layer, GenerativeDesign, PositionPreset, BlendMode } from "@/lib/generative-types";
import {
    Typography,
    GlassCard,
    Badge,
    ShapeBlob,
    GridPattern,
    GradientOverlay,
    AccentLine,
    CornerAccent,
    NoiseOverlay,
    MeshGradient,
    ColorFilter,
    FONT_PAIRS,
    type FontPairId,
} from "@/components/atoms";

// Component registry - maps string names to React components
const ComponentMap: Record<string, React.ComponentType<Record<string, unknown>>> = {
    Typography: Typography as unknown as React.ComponentType<Record<string, unknown>>,
    GlassCard: GlassCard as unknown as React.ComponentType<Record<string, unknown>>,
    Badge: Badge as unknown as React.ComponentType<Record<string, unknown>>,
    ShapeBlob: ShapeBlob as unknown as React.ComponentType<Record<string, unknown>>,
    GridPattern: GridPattern as unknown as React.ComponentType<Record<string, unknown>>,
    GradientOverlay: GradientOverlay as unknown as React.ComponentType<Record<string, unknown>>,
    AccentLine: AccentLine as unknown as React.ComponentType<Record<string, unknown>>,
    CornerAccent: CornerAccent as unknown as React.ComponentType<Record<string, unknown>>,
    NoiseOverlay: NoiseOverlay as unknown as React.ComponentType<Record<string, unknown>>,
    MeshGradient: MeshGradient as unknown as React.ComponentType<Record<string, unknown>>,
    ColorFilter: ColorFilter as unknown as React.ComponentType<Record<string, unknown>>,
};

// Stock Photo component (handles async image loading + color filter)
interface StockPhotoProps {
    imageUrl?: string;
    position: PositionPreset;
    blend_mode?: BlendMode;
    opacity?: number;
    color_filter?: string; // V2.1: Apply duotone effect
}

function StockPhoto({ imageUrl, position, blend_mode = "normal", opacity = 1, color_filter }: StockPhotoProps) {
    if (!imageUrl) return null;

    const positionStyles: Record<PositionPreset, React.CSSProperties> = {
        "center": { top: 0, left: 0, width: "100%", height: "100%" },
        "left-half": { top: 0, left: 0, width: "50%", height: "100%" },
        "right-half": { top: 0, right: 0, width: "50%", height: "100%" },
        "top-half": { top: 0, left: 0, width: "100%", height: "50%" },
        "bottom-half": { bottom: 0, left: 0, width: "100%", height: "50%" },
        "top-left": { top: 0, left: 0, width: "50%", height: "50%" },
        "top-right": { top: 0, right: 0, width: "50%", height: "50%" },
        "bottom-left": { bottom: 0, left: 0, width: "50%", height: "50%" },
        "bottom-right": { bottom: 0, right: 0, width: "50%", height: "50%" },
    };

    // Generate CSS filter for color wash if specified
    const colorWashFilter = color_filter ? `saturate(120%) brightness(105%) sepia(20%)` : undefined;

    return (
        <div
            style={{
                position: "absolute",
                ...positionStyles[position],
                display: "flex",
                overflow: "hidden",
            }}
        >
            <img
                src={imageUrl}
                alt="Background"
                style={{
                    width: "100%",
                    height: "100%",
                    objectFit: "cover",
                    mixBlendMode: blend_mode,
                    opacity,
                    filter: colorWashFilter,
                }}
            />
            {/* Color overlay for tinting */}
            {color_filter && (
                <div
                    style={{
                        position: "absolute",
                        top: 0,
                        left: 0,
                        width: "100%",
                        height: "100%",
                        backgroundColor: `${color_filter}30`,
                        mixBlendMode: "overlay",
                        display: "flex",
                    }}
                />
            )}
        </div>
    );
}

// Add StockPhoto to registry
ComponentMap.StockPhoto = StockPhoto as unknown as React.ComponentType<Record<string, unknown>>;

// Layer Renderer - recursively renders component tree
interface LayerRendererProps {
    layers: Layer[];
    imageUrl?: string; // For StockPhoto components
}

export function LayerRenderer({ layers, imageUrl }: LayerRendererProps) {
    return (
        <>
            {layers.map((layer, index) => {
                const Component = ComponentMap[layer.component];

                if (!Component) {
                    console.warn(`Unknown component: ${layer.component}`);
                    return null;
                }

                // Inject imageUrl for StockPhoto
                const enhancedProps = layer.component === "StockPhoto"
                    ? { ...layer.props, imageUrl }
                    : layer.props;

                // Layer positioning wrapper
                const wrapperStyle: React.CSSProperties = layer.style ? {
                    position: "absolute",
                    left: layer.style.x ?? undefined,
                    top: layer.style.y ?? undefined,
                    width: layer.style.width ?? undefined,
                    height: layer.style.height ?? undefined,
                    zIndex: layer.style.zIndex ?? index,
                    display: "flex",
                } : {
                    display: "flex",
                    zIndex: index,
                };

                // Render with children if present
                if (layer.children && layer.children.length > 0) {
                    return (
                        <div style={wrapperStyle} key={index}>
                            <Component {...enhancedProps}>
                                <LayerRenderer layers={layer.children} imageUrl={imageUrl} />
                            </Component>
                        </div>
                    );
                }

                return (
                    <div style={wrapperStyle} key={index}>
                        <Component {...enhancedProps} />
                    </div>
                );
            })}
        </>
    );
}

// Main Canvas Component with Font Pair support
interface GenerativeCanvasProps {
    design: GenerativeDesign;
    imageUrl?: string;
    isEditing?: boolean;
    onUpdateContent?: (field: "headline" | "subheadline" | "cta", value: string) => void;
}

export function GenerativeCanvas({ design, imageUrl }: GenerativeCanvasProps) {
    const { canvas, layers } = design;

    // Get font pair from canvas config
    const canvasAny = canvas as unknown as { font_pair?: FontPairId };
    const fontPairId = canvasAny.font_pair || "modern";
    const fontPair = FONT_PAIRS[fontPairId] || FONT_PAIRS.modern;

    return (
        <div
            style={{
                position: "relative",
                width: "100%",
                aspectRatio: `${canvas.width}/${canvas.height}`,
                backgroundColor: canvas.bg_color,
                overflow: "hidden",
                fontFamily: fontPair.body,
            }}
        >
            <LayerRenderer layers={layers} imageUrl={imageUrl} />
        </div>
    );
}

export default GenerativeCanvas;
